#pragma once

#include "vem_mesh2.hpp"

struct PointwiseVEMMesh2 : public VEMMesh2 {
    double projection_lambda = 1000.0;

    mtao::MatXd per_cell_laplacian(size_t index) const override;

    // projects sample values to sample values that can be generated by a poly
    // return the projection operator and its nullspace
    // Let T have column vectors be the monomials evaluated at points
    // Then Span(T) is the space of polynomial terms
    // T^* T maps coefficients to coefficients where there can only be #C
    // nonzero eigenvalues
    // We let the column vectors of
    std::array<mtao::MatXd, 2> poly_projection_sample2sample(
        size_t index, const std::vector<size_t>& sample_indices) const;
    std::array<mtao::MatXd, 2> poly_projection_sample2sample(
        size_t index) const;

    // reports a regression error operator with respect to the sample2cell
    // operator
    Eigen::SparseMatrix<double> regression_error_bilinear(
        const std::set<size_t>& disengaged_cells = {}) const;
    Eigen::SparseMatrix<double> gradient_sample2poly() const;
    Eigen::SparseMatrix<double> gradient_sample2sample() const override;
    Eigen::SparseMatrix<double> divergence_sample2poly() const;
    Eigen::SparseMatrix<double> divergence_sample2sample() const;
    Eigen::SparseMatrix<double> integrated_divergence_sample2sample() const;
    Eigen::SparseMatrix<double> integrated_divergence_sample2adj_sample() const;
    Eigen::SparseMatrix<double> integrated_divergence_poly2adj_sample(
        const std::set<size_t>& disengaged_cells = {}) const;
    virtual mtao::MatXd laplacian_sample2sample(
        const std::set<size_t>& disengaged_cells = {}) const override;

    Eigen::SparseMatrix<double> sample2cell_coefficients(
        const std::set<size_t>& disengaged_cells = {}) const;
    // auto V(int index) const { return vertices.col(index); }
    // p_C(x) = C * T(x)
    // p_C(x) * T^*(x) = C * T(x) T^*(x)
    // p_C(x) * T^*(x) (T(x) T^*(x))^-1 = C * T(x) T^*(x)
    mtao::MatXd poly_projection_sample2poly(
        size_t index, const std::vector<size_t>& sample_indices) const;
    mtao::MatXd poly_projection_sample2poly(size_t index) const;
    Eigen::SparseMatrix<double> poly_projection_sample2poly(
        const std::set<size_t>& disengaged_cells = {}) const;

    mtao::MatXd poly_projection_kernel(
        size_t index, const std::vector<size_t>& sample_indices) const;
    mtao::MatXd poly_projection_kernel(size_t index) const;
    Eigen::SparseMatrix<double> poly_projection_kernel(
        const std::set<size_t>& disengaged_cells = {}) const;
    // the default implementation is to set the _jump_ over a boundary to be the
    // desired condition
    virtual std::tuple<Eigen::SparseMatrix<double>, mtao::VecXd>
    orthogonal_neumann_entries(
        const std::map<size_t, double>& target_fluxes = {}) const override;
};
