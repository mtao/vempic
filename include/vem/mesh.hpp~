#pragma once
#include <map>
#include <mtao/types.hpp>
#include <vector>

namespace vem {
struct VEMTopology2 {
    mtao::ColVecs2i E;
    std::vector<std::map<int, bool>> face_boundary_map;

    int cell_count() const { return face_boundary_map.size(); }

    std::vector<std::vector<int>> face_loops() const;
};

// similar to vemtopology2 but we expect to need to see the face loops
// consistently.
struct VEMTopology3 : public VEMTopology2 {
    // a cached copy of the VEMTopology2's face_loops
    // it may be faster to use face_boundary_map to do operations on the edges?
    std::vector<std::vector<int>> F;
    std::vector<std::map<int, bool>> cell_boundary_map;
    int cell_count() const { return F.size(); }
};

struct VEMMesh2 : public VEMTopology2 {
    // vertex positions
    mtao::ColVecs2d V;
    // centers
    mtao::ColVecs2d C;

    VEMMesh2() = default;
    VEMMesh2(const VEMMesh2&) = default;
    VEMMesh2(VEMMesh2&&) = default;
    VEMMesh2(VEMTopology2&& top) : VEMTopology2(top) {}
    VEMMesh2& operator=(const VEMMesh2&) = default;
    VEMMesh2& operator=(VEMMesh2&&) = default;
    VEMMesh2(VEMTopology2&& T, mtao::ColVecs2d V);
};
struct VEMMesh3 : public VEMTopology3 {
    // vertex positions
    mtao::ColVecs3d V;
    // centers
    mtao::ColVecs3d C;

    VEMMesh3() = default;
    VEMMesh3(const VEMMesh3&) = default;
    VEMMesh3(VEMMesh3&&) = default;
    VEMMesh3(VEMTopology3&& top) : VEMTopology3(top) {}
    VEMMesh3& operator=(const VEMMesh3&) = default;
    VEMMesh3& operator=(VEMMesh3&&) = default;
    VEMMesh3(VEMTopology3&& T, mtao::ColVecs3d V);
};
}  // namespace vem
